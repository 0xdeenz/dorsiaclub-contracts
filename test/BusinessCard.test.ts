import { expect } from "chai";
import { Signer, constants } from "ethers"
import { run } from "hardhat";
import { describe } from "mocha";
import {
    DCT_AIRDROP,
    DCT_AIRDROP_SUPPLY,
    MAX_DCT_SUPPLY,
    MAX_NAME_CHARACTERS,
    MAX_POSITION_CHARACTERS,
    MAX_SUPPLY,
    MINT_PRICE,
    ORACLE_FEE,
    UPDATE_PRICE
} from "./utils";
import {
    BusinessCard,
    DorsiaClubToken,
    BusinessCard__factory,
    DorsiaClubToken__factory
} from "../typechain-types";

describe("BusinessCard smart contract", () => {
    let businessCard: BusinessCard;
    let dct: DorsiaClubToken;

    let signers: Signer[];
    let accounts: string[];
    let oracleAddress: string;
    let owner: string;
    let minter: string;

    // Example cardName and cardProperties
    const cardProperties = {
        position: 'Vice President',
        twitterAccount: 'twitterAccount',
        telegramAccount: 'telegramAccount',
        githubAccount: 'githubAccount',
        website: 'website.com'
    }
    
    const firstToken = {
        cardName: 'Patrick BATEMAN',
        cardProperties
    };
    
    const secondToken = {
        cardName: 'Paul ALLEN',
        cardProperties
    };
    
    const thirdToken = {
        cardName: 'David VAN PATTEN',
        cardProperties
    };

    // URI parameters
    const baseUri = 'https://gateway.pinata.cloud/ipfs/Qm';
    const altBaseUri ='https://gateway.ipfs.io/ipfs/Qm'
    const defaultUri = 'bFp3rybuvZ7j9e4xB6WLedu8gvLcjbVqUrGUEugQWz9u';

    // Filler values, would be dynamically generated by the server oracle
    const cardURI = 'Ur63bgQq3VWW9XsVviDGAFwYEZVs9AFWsTd56T9xCQmf'
    const altCardURI = 'UANYk2Bga9sQiqtr3Gfk1Q7Mw1pUG16GesLYstWyDzrr'

    before(async () => {
        signers = await run("accounts")
        accounts = await Promise.all(signers.map((signer: Signer) => signer.getAddress()))
    })

    beforeEach(async () => {
        oracleAddress = accounts[9]
        owner = accounts[0]
        minter = accounts[1]

        const { businessCardAddress, dctAddress } = await run("deploy:business-card", { 
            baseUri,
            defaultUri,
            oracleAddress,
            startSale: false,
            deployMarketplace: false
        })

        businessCard = BusinessCard__factory.connect(businessCardAddress, signers[1])
        dct = DorsiaClubToken__factory.connect(dctAddress, signers[1])
    })

    describe("DorsiaClubToken contract", () => {
        context("after deploying the Business Card smart contract", () => {
            it(`Sends ${MAX_DCT_SUPPLY.sub(DCT_AIRDROP_SUPPLY)} DCT tokens to the owner, the supply not reserved for minting`, async () => {
                expect(await dct.balanceOf(owner))
                    .to.be.equal(MAX_DCT_SUPPLY.sub(DCT_AIRDROP_SUPPLY)) 
            })
        })
    })

    describe("getCard", () => {
        context("with unitiated sale", () => {
            it("reverts", async () => {
                await expect(
                    businessCard.getCard(firstToken.cardName, firstToken.cardProperties, { value: MINT_PRICE })
                ).to.be.revertedWithCustomError(
                    businessCard,
                    "SaleNotActive"
                )
            })
        })

        context("with initiated sale", () => {
            beforeEach(async () => {
                await businessCard.connect(signers[0]).startSale()
            })

            context("when all cards have been minted", () => {
                it("reverts", async () => {
                    const charset = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';

                    for(var i = 0; i < MAX_SUPPLY; i++) {
                        let cardName = '';

                        for (let i = 0; i < MAX_NAME_CHARACTERS; i++) {
                            cardName += charset.charAt(Math.floor(Math.random() * charset.length));
                        }

                        await businessCard.getCard(cardName, firstToken.cardProperties, { value: MINT_PRICE })
                    }

                    await expect(
                        businessCard.getCard(firstToken.cardName, firstToken.cardProperties, { value: MINT_PRICE })
                    ).to.be.revertedWithCustomError(
                        businessCard,
                        "SaleHasEnded"
                    )
                })
            })

            context("when the value sent is below the price", () => {
                it("reverts", async () => {
                    await expect(
                        businessCard.getCard(firstToken.cardName, firstToken.cardProperties, { value: MINT_PRICE.sub(1) })
                    ).to.be.revertedWithCustomError(
                        businessCard,
                        "PriceTooLow"
                    )
                })
            })

            context("when the name given has invalid characters", () => {
                it("reverts", async () => {
                    await expect(
                        businessCard.getCard("~", firstToken.cardProperties, { value: MINT_PRICE })
                    ).to.be.revertedWithCustomError(
                        businessCard,
                        "NonValidCharacters"
                    )
                })
            })

            context("when the name given is an empty string", () => {
                it("reverts", async () => {
                    await expect(
                        businessCard.getCard("", firstToken.cardProperties, { value: MINT_PRICE })
                    ).to.be.revertedWithCustomError(
                        businessCard,
                        "NameNotValid"
                    )
                })
            })

            context("when the name given has leading/trailing spaces", () => {
                it("reverts", async () => {
                    await expect(
                        businessCard.getCard(" sneed", firstToken.cardProperties, { value: MINT_PRICE })
                    ).to.be.revertedWithCustomError(
                        businessCard,
                        "NameNotValid"
                    )

                    await expect(
                        businessCard.getCard("sneed ", firstToken.cardProperties, { value: MINT_PRICE })
                    ).to.be.revertedWithCustomError(
                        businessCard,
                        "NameNotValid"
                    )
                })
            })

            context(`when the name given is longer than ${MAX_NAME_CHARACTERS} characters`, () => {
                it("reverts", async () => {
                    await expect(
                        businessCard.getCard("A".repeat(MAX_NAME_CHARACTERS + 1), firstToken.cardProperties, { value: MINT_PRICE })
                    ).to.be.revertedWithCustomError(
                        businessCard,
                        "NameNotValid"
                    )
                })
            })

            context("when the name given is taken", () => {
                it("reverts", async () => {
                    await businessCard.getCard(firstToken.cardName, firstToken.cardProperties, { value: MINT_PRICE })

                    await expect(
                        businessCard.getCard(firstToken.cardName, firstToken.cardProperties, { value: MINT_PRICE })
                    ).to.be.revertedWithCustomError(
                        businessCard,
                        "NameIsTaken"
                    )
                })
            })

            context("when the position given has invalid characters", () => {
                it("reverts", async () => {
                    await expect(
                        businessCard.getCard(firstToken.cardName, { ...firstToken.cardProperties, position: "~" }, { value: MINT_PRICE })
                    ).to.be.revertedWithCustomError(
                        businessCard,
                        "NonValidCharacters"
                    )
                })
            })

            context("when the position given is an empty string", () => {
                it("reverts", async () => {
                    await expect(
                        businessCard.getCard(firstToken.cardName, { ...firstToken.cardProperties, position: "" }, { value: MINT_PRICE })
                    ).to.be.revertedWithCustomError(
                        businessCard,
                        "PositionNotValid"
                    )
                })
            })

            context("when the position given has leading/trailing spaces", () => {
                it("reverts", async () => {
                    await expect(
                        businessCard.getCard(firstToken.cardName, { ...firstToken.cardProperties, position: " sneed" }, { value: MINT_PRICE })
                    ).to.be.revertedWithCustomError(
                        businessCard,
                        "PositionNotValid"
                    )

                    await expect(
                        businessCard.getCard(firstToken.cardName, { ...firstToken.cardProperties, position: "sneed " }, { value: MINT_PRICE })
                    ).to.be.revertedWithCustomError(
                        businessCard,
                        "PositionNotValid"
                    )
                })
            })

            context(`when the position given is longer than ${MAX_POSITION_CHARACTERS} characters`, () => {
                it("reverts", async () => {
                    await expect(
                        businessCard.getCard(firstToken.cardName, { ...firstToken.cardProperties, position: "A".repeat(MAX_POSITION_CHARACTERS + 1) }, { value: MINT_PRICE })
                    ).to.be.revertedWithCustomError(
                        businessCard,
                        "PositionNotValid"
                    )
                })
            })

            context("when the twitterAccount given is longer than 15 characters", () => {
                it("reverts", async () => {
                    await expect(
                        businessCard.getCard(firstToken.cardName, { ...firstToken.cardProperties, twitterAccount: "A".repeat(16) }, { value: MINT_PRICE })
                    ).to.be.revertedWithCustomError(
                        businessCard,
                        "PropertiesNotValid"
                    )
                })
            })

            context("when the telegramAccount given is longer than 32 characters", () => {
                it("reverts", async () => {
                    await expect(
                        businessCard.getCard(firstToken.cardName, { ...firstToken.cardProperties, telegramAccount: "A".repeat(33) }, { value: MINT_PRICE })
                    ).to.be.revertedWithCustomError(
                        businessCard,
                        "PropertiesNotValid"
                    )
                })
            })

            context("when the githubAccount given is longer than 39 characters", () => {
                it("reverts", async () => {
                    await expect(
                        businessCard.getCard(firstToken.cardName, { ...firstToken.cardProperties, githubAccount: "A".repeat(40) }, { value: MINT_PRICE })
                    ).to.be.revertedWithCustomError(
                        businessCard,
                        "PropertiesNotValid"
                    )
                })
            })

            context("when the website given is longer than 50 characters", () => {
                it("reverts", async () => {
                    await expect(
                        businessCard.getCard(firstToken.cardName, { ...firstToken.cardProperties, website: "A".repeat(51) }, { value: MINT_PRICE })
                    ).to.be.revertedWithCustomError(
                        businessCard,
                        "PropertiesNotValid"
                    )
                })
            })

            context("after a successful mint", () => {
                let tx: any; 

                beforeEach(async () => {
                    tx = await businessCard.getCard(firstToken.cardName, firstToken.cardProperties, { value: MINT_PRICE })
                })
        
                it("mints a business card to the msg.sender", async () => {
                    expect(await businessCard.balanceOf(minter))
                        .to.be.equal(1)

                    expect(await businessCard.ownerOf(1))
                        .to.be.equal(minter)
                })

                it("saves the name given", async () => {
                    expect((await businessCard.getCardStats(1)).name)
                        .to.be.equal(firstToken.cardName)
                })

                it("reserves the name given", async () => {
                    expect(await businessCard.isNameReserved(firstToken.cardName.toLowerCase()))
                        .to.be.equal(true)
                })

                it("generates an appropriate length genes number", async () => {
                    const genes = await businessCard.getCardGenes(1)

                    expect(genes.toString().length).to.be.at.most(30)
                    expect(genes.toString().length).to.be.at.least(28)
                })

                it("emits a Transfer event", async () => {
                    await expect(tx)
                        .to.emit(businessCard, "Transfer")
                        .withArgs(constants.AddressZero, minter, 1)
                })

                it(`Sends ${DCT_AIRDROP} DCT tokens to the msg.sender`, async () => {
                    expect(await dct.balanceOf(minter))
                        .to.be.equal(DCT_AIRDROP)
                })

                it("emits a DCT Transfer event", async () => {
                    await expect(tx)
                        .to.emit(dct, "Transfer")
                        .withArgs(businessCard.address, minter, DCT_AIRDROP)
                })

                it("emits a CardDataUpdateRequest event", async () => {
                    const genes = await businessCard.getCardGenes(1)
                    const receipt = await tx.wait()

                    const event = receipt.events?.filter((x: any) => {return x.event == "CardDataUpdateRequest"})[0].args

                    // Need to unroll as you cannot easily match structs on hardhat chai matchers
                    expect(event.cardId).to.be.equal(1)
                    expect(event.genes).to.be.equal(genes)
                    expect(event.cardName).to.be.equal(firstToken.cardName)
                    // Father forgive me
                    expect(event.cardProperties.slice(0, 5)).to.deep.equal(Object.values(firstToken.cardProperties))
                })

                it("funds the server oracle", async () => {
                    expect(tx).to.changeEtherBalance(oracleAddress, ORACLE_FEE)
                })
                
                it("generates a request associated with its cardId", async () => {
                    expect(await businessCard.requests(1))
                        .to.be.equal(true)
                })
            })
        })
    })

    describe("updateCardData", () => {
        context("with a paused sale", () => {
            it("reverts", async () => {
                await expect(
                    businessCard.updateCardData(1, secondToken.cardName, secondToken.cardProperties, { value: UPDATE_PRICE })
                ).to.be.revertedWithCustomError(
                    businessCard,
                    "SaleNotActive"
                )
            })
        })

        context("with an active sale", () => {
            beforeEach(async () => {
                await businessCard.connect(signers[0]).startSale()
                await businessCard.getCard(firstToken.cardName, firstToken.cardProperties, { value: MINT_PRICE })
                await businessCard.connect(signers[9]).updateCallback(1, cardURI)
            })

            context("when calling for a non existing token", () => {
                it("reverts", async () => {
                    await expect(
                        businessCard.updateCardData(2, secondToken.cardName, secondToken.cardProperties, { value: UPDATE_PRICE })
                    ).to.be.revertedWith(
                        "ERC721: invalid token ID"
                    )
                })
            })

            context("when the caller is not owner or approved", () => {
                it("reverts", async () => {
                    await expect(
                        businessCard.connect(signers[2]).updateCardData(1, secondToken.cardName, secondToken.cardProperties, { value: UPDATE_PRICE })
                    ).to.be.revertedWithCustomError(
                        businessCard,
                        "CallerMustBeOwnerOrApproved"
                    )
                })
            })

            context("when the value given is too low", () => {
                it("reverts", async () => {
                    await expect(
                        businessCard.updateCardData(1, secondToken.cardName, secondToken.cardProperties, { value: UPDATE_PRICE.sub(1) })
                    ).to.be.revertedWithCustomError(
                        businessCard,
                        "PriceTooLow"
                    )
                })
            })

            context("when the new name has invalid characters", () => {
                it("reverts", async () => {
                    await expect(
                        businessCard.updateCardData(1, "~", secondToken.cardProperties, { value: UPDATE_PRICE })
                    ).to.be.revertedWithCustomError(
                        businessCard,
                        "NonValidCharacters"
                    )
                })
            })

            context("when the new name is taken", () => {
                // old name is also taken until tx clears, so it will equally revert
                it("reverts", async () => {
                    await expect(
                        businessCard.updateCardData(1, firstToken.cardName, firstToken.cardProperties, { value: UPDATE_PRICE })
                    ).to.be.revertedWithCustomError(
                        businessCard,
                        "NameIsTaken"
                    )
                })
            })

            context("when the new name is an empty string", () => {
                it("leaves the card name as it was", async () => {
                    businessCard.updateCardData(1, "", secondToken.cardProperties, { value: UPDATE_PRICE })

                    expect((await businessCard.getCardStats(1))[0])
                        .to.be.equal(firstToken.cardName)
                })
            })

            context("when the new name has leading/trailing spaces", () => {
                it("reverts", async () => {
                    await expect(
                        businessCard.updateCardData(1, " sneed", secondToken.cardProperties, { value: UPDATE_PRICE })
                    ).to.be.revertedWithCustomError(
                        businessCard,
                        "NameNotValid"
                    )

                    await expect(
                        businessCard.updateCardData(1, "sneed ", secondToken.cardProperties, { value: UPDATE_PRICE })
                    ).to.be.revertedWithCustomError(
                        businessCard,
                        "NameNotValid"
                    )
                })
            })

            context(`when the new name is longer than ${MAX_NAME_CHARACTERS} characters`, () => {
                it("reverts", async () => {
                    await expect(
                        businessCard.updateCardData(1, "A".repeat(MAX_NAME_CHARACTERS + 1), secondToken.cardProperties, { value: MINT_PRICE })
                    ).to.be.revertedWithCustomError(
                        businessCard,
                        "NameNotValid"
                    )
                })
            })

            context("when the new position has invalid characters", () => {
                it("reverts", async () => {
                    await expect(
                        businessCard.updateCardData(1, secondToken.cardName, { ...secondToken.cardProperties, position: "~" }, { value: MINT_PRICE })
                    ).to.be.revertedWithCustomError(
                        businessCard,
                        "NonValidCharacters"
                    )
                })
            })

            context("when the new position is an empty string", () => {
                it("updates the card", async () => {
                    await businessCard.updateCardData(1, secondToken.cardName, { ...secondToken.cardProperties, position: "" }, { value: MINT_PRICE })
                })
            })

            context("when the new position has leading/trailing spaces", () => {
                it("reverts", async () => {
                    await expect(
                        businessCard.updateCardData(1, secondToken.cardName, { ...secondToken.cardProperties, position: " sneed" }, { value: MINT_PRICE })
                    ).to.be.revertedWithCustomError(
                        businessCard,
                        "PositionNotValid"
                    )

                    await expect(
                        businessCard.updateCardData(1, secondToken.cardName, { ...secondToken.cardProperties, position: "sneed " }, { value: MINT_PRICE })
                    ).to.be.revertedWithCustomError(
                        businessCard,
                        "PositionNotValid"
                    )
                })
            })

            context(`when the position given is longer than ${MAX_POSITION_CHARACTERS} characters`, () => {
                it("reverts", async () => {
                    await expect(
                        businessCard.updateCardData(1, secondToken.cardName, { ...secondToken.cardProperties, position: "A".repeat(MAX_POSITION_CHARACTERS + 1) }, { value: MINT_PRICE })
                    ).to.be.revertedWithCustomError(
                        businessCard,
                        "PositionNotValid"
                    )
                })
            })

            context("when a request for this token ID is already being processed", () => {
                it("reverts", async () => {
                    await businessCard.getCard(secondToken.cardName, secondToken.cardProperties, { value: MINT_PRICE })

                    await expect(
                        businessCard.updateCardData(2, thirdToken.cardName, thirdToken.cardProperties, { value: MINT_PRICE })
                    ).to.be.revertedWithCustomError(
                        businessCard,
                        "RequestBeingProcessed"
                    )
                })
            })

            context("after a successful call", () => {
                let tx: any;

                beforeEach(async () => {
                    tx = await businessCard.updateCardData(1, secondToken.cardName, secondToken.cardProperties, { value: MINT_PRICE })
                })

                it("emits a CardDataUpdateRequest event", async () => {
                    const genes = await businessCard.getCardGenes(1)
                    const receipt = await tx.wait()

                    const event = receipt.events?.filter((x: any) => {return x.event == "CardDataUpdateRequest"})[0].args

                    // Need to unroll as you cannot easily match structs on hardhat chai matchers
                    expect(event.cardId).to.be.equal(1)
                    expect(event.genes).to.be.equal(genes)
                    expect(event.cardName).to.be.equal(secondToken.cardName)
                    // Father forgive me
                    expect(event.cardProperties.slice(0, 5)).to.deep.equal(Object.values(secondToken.cardProperties))
                })

                it("dereserves old name and reserves the new name", async () => {
                    expect(await businessCard.isNameReserved(firstToken.cardName.toLowerCase()))
                        .to.be.equal(false)

                    expect(await businessCard.isNameReserved(secondToken.cardName.toLowerCase()))
                        .to.be.equal(true)
                })

                it("funds the server oracle", async () => {
                    expect(tx).to.changeEtherBalance(oracleAddress, ORACLE_FEE)
                })

                it("generates a request associated with its cardId", async () => {
                    expect(await businessCard.requests(1))
                        .to.be.equal(true)
                })
            })
        })
    })

    describe("swapCardData", () => {
        context("with a paused sale", () => {
            it("reverts", async () => {
                await expect(
                    businessCard.swapCardData(1, 2, { value: UPDATE_PRICE })
                ).to.be.revertedWithCustomError(
                    businessCard,
                    "SaleNotActive"
                )
            })
        })

        context("with an active sale", () => {
            beforeEach(async () => {
                await businessCard.connect(signers[0]).startSale()

                await businessCard.getCard(firstToken.cardName, firstToken.cardProperties, { value: MINT_PRICE })
                await businessCard.connect(signers[9]).updateCallback(1, cardURI)

                await businessCard.getCard(secondToken.cardName, secondToken.cardProperties, { value: MINT_PRICE })
                await businessCard.connect(signers[9]).updateCallback(2, cardURI)
            })

            context("when calling for non existing tokens", () => {
                it("reverts", async () => {
                    await expect(
                        businessCard.swapCardData(1, 3, { value: UPDATE_PRICE })
                    ).to.be.revertedWith(
                        "ERC721: invalid token ID"
                    )

                    await expect(
                        businessCard.swapCardData(3, 2, { value: UPDATE_PRICE })
                    ).to.be.revertedWith(
                        "ERC721: invalid token ID"
                    )
                })
            })

            context("when the caller is not owner or approved for both tokens", () => {
                it("reverts", async () => {
                    await expect(
                        businessCard.connect(signers[2]).swapCardData(1, 2, { value: UPDATE_PRICE })
                    ).to.be.revertedWithCustomError(
                        businessCard,
                        "CallerMustBeOwnerOrApproved"
                    )
                })
            })

            context("when the value given is too low", () => {
                it("reverts", async () => {
                    await expect(
                        businessCard.swapCardData(1, 2, { value: UPDATE_PRICE.sub(1) })
                    ).to.be.revertedWithCustomError(
                        businessCard,
                        "PriceTooLow"
                    )
                })
            })

            context("when a request for one of the token IDs is already being processed", () => {
                it("reverts", async () => {
                    await businessCard.updateCardData(2, thirdToken.cardName, thirdToken.cardProperties, { value: MINT_PRICE })

                    await expect(
                        businessCard.swapCardData(1, 2, { value: UPDATE_PRICE })
                    ).to.be.revertedWithCustomError(
                        businessCard,
                        "RequestBeingProcessed"
                    )
                })
            })

            context("after a successful call", () => {
                let tx: any;

                beforeEach(async () => {
                    tx = await businessCard.swapCardData(1, 2, { value: UPDATE_PRICE })
                })

                it("emits a CardDataSwapRequest event", async () => {
                    const genes1 = await businessCard.getCardGenes(1)
                    const genes2 = await businessCard.getCardGenes(2)

                    await expect(tx)
                        .to.emit(businessCard, "CardDataSwapRequest")
                        .withArgs(1, 2, genes1, genes2)
                })

                it("swaps the stored names", async () => {
                    expect((await businessCard.getCardStats(1))[0])
                        .to.be.equal(secondToken.cardName)

                    expect((await businessCard.getCardStats(2))[0])
                        .to.be.equal(firstToken.cardName)
                })

                it("keeps both names reserved", async () => {
                    expect(await businessCard.isNameReserved(firstToken.cardName.toLowerCase()))
                        .to.be.equal(true)
                    
                    expect(await businessCard.isNameReserved(secondToken.cardName.toLowerCase()))
                        .to.be.equal(true)
                })

                it("generates two request associated with their cardIds", async () => {
                    expect(await businessCard.requests(1))
                        .to.be.equal(true)

                    expect(await businessCard.requests(2))
                        .to.be.equal(true)
                })
            })
        })
    })

    describe("startSale", () => {
        beforeEach(async () => {
            // Sale is paused to be activated again
            await businessCard.connect(signers[0]).pauseSale()
        })

        context("when being called by someone other than the contract owner", () => {
            it("reverts", async () => {
                await expect(
                    businessCard.startSale()
                ).to.be.revertedWith(
                    "Ownable: caller is not the owner"
                )
            })
        })

        context("when the oracle is not defined", () => {
            it("reverts", async () => {
                await businessCard.connect(signers[0]).setOracle(constants.AddressZero)
                
                await expect(
                    businessCard.connect(signers[0]).startSale()
                ).to.be.revertedWithCustomError(
                    businessCard,
                    "OracleIsNotDefined"
                )
            })
        })

        context("after a successful call", () => {
            beforeEach(async () => {
                await businessCard.connect(signers[0]).startSale()
            })

            it("sets the vale for `saleStarted` to true", async () => {
                expect(await businessCard.saleStarted())
                    .to.be.equal(true)
            })

            it("permits the minting, updating and swapping of Business Cards", async () => {
                // Can mint
                await businessCard.getCard(firstToken.cardName, firstToken.cardProperties, { value: MINT_PRICE })
                await businessCard.getCard(secondToken.cardName, secondToken.cardProperties, { value: MINT_PRICE })
                await businessCard.connect(signers[9]).updateCallback(1, cardURI)
                await businessCard.connect(signers[9]).updateCallback(2, cardURI)

                // Can update
                await businessCard.updateCardData(1, thirdToken.cardName, thirdToken.cardProperties, { value: UPDATE_PRICE })
                await businessCard.connect(signers[9]).updateCallback(1, cardURI)

                // Can swap
                await businessCard.swapCardData(1, 2, { value: UPDATE_PRICE })
            })
        })
    })

    describe("pauseSale", () => {
        context("when being called by someone other than the contract owner", () => {
            it("reverts", async () => {
                await expect(
                    businessCard.pauseSale()
                ).to.be.revertedWith(
                    "Ownable: caller is not the owner"
                )
            })
        })

        context("after a successful call", () => {
            before(async () => {
                await businessCard.connect(signers[0]).pauseSale()
            })

            it("sets the vale for `saleStarted` to false", async () => {
                expect(await businessCard.saleStarted())
                    .to.be.equal(false)
            })

            it("does not permit the minting, updating and swapping of Business Cards", async () => {
                // Minting
                await expect(
                    businessCard.getCard(firstToken.cardName, firstToken.cardProperties, { value: MINT_PRICE })
                ).to.be.revertedWithCustomError(
                    businessCard,
                    "SaleNotActive"
                )

                // Updating
                await expect(
                    businessCard.updateCardData(1, secondToken.cardName, secondToken.cardProperties, { value: UPDATE_PRICE })
                ).to.be.revertedWithCustomError(
                    businessCard,
                    "SaleNotActive"
                )

                // Swapping
                await expect(
                    businessCard.swapCardData(1, 2, { value: UPDATE_PRICE })
                ).to.be.revertedWithCustomError(
                    businessCard,
                    "SaleNotActive"
                )
            })
        })
    })

    describe("updateCallback", () => {
        beforeEach(async () => {
            await businessCard.connect(signers[0]).startSale()

            await businessCard.getCard(firstToken.cardName, firstToken.cardProperties, { value: MINT_PRICE })
        })

        context("when being called by someone other than the server oracle", () => {
            it("reverts", async () => {
                await expect(
                    businessCard.updateCallback(1, cardURI)
                ).to.be.revertedWithCustomError(
                    businessCard,
                    "CallerMustBeOracle"
                )
            })
        })

        context("when the cardId is not in the pending request list", () => {
            it("reverts", async () => {
                // Fill the request first
                await businessCard.connect(signers[9]).updateCallback(1, cardURI)

                await expect(
                    businessCard.connect(signers[9]).updateCallback(1, cardURI)
                ).to.be.revertedWithCustomError(
                    businessCard,
                    "RequestNotInPendingList"
                )
            })
        })

        context("after a successful call", () => {
            let tx: any;

            beforeEach(async () => {
                tx = await businessCard.connect(signers[9]).updateCallback(1, cardURI)
            })

            it("sets the cardURI to the newly provided value", async () => {
                expect(await businessCard.tokenURI(1))
                    .to.be.equal(baseUri + cardURI)
            })

            it("removes the pending request for this cardId", async () => {
                expect(await businessCard.requests(1))
                    .to.be.equal(false)
            })

            it("emits a CardURIUpdated event", async () => {
                await expect(tx)
                    .to.emit(businessCard, "CardURIUpdated")
                    .withArgs(1, baseUri + cardURI)
            })
        })
    })

    describe("swapCallback", () => {
        beforeEach(async () => {
            await businessCard.connect(signers[0]).startSale()

            await businessCard.getCard(firstToken.cardName, firstToken.cardProperties, { value: MINT_PRICE })
            await businessCard.connect(signers[9]).updateCallback(1, cardURI)
            
            await businessCard.getCard(secondToken.cardName, secondToken.cardProperties, { value: MINT_PRICE })
            await businessCard.connect(signers[9]).updateCallback(2, cardURI)

            await businessCard.swapCardData(1, 2, { value: UPDATE_PRICE })
        })

        context("when being called by someone other than the server oracle", () => {
            it("reverts", async () => {
                await expect(
                    businessCard.swapCallback(1, 2, altCardURI, altCardURI)
                ).to.be.revertedWithCustomError(
                    businessCard,
                    "CallerMustBeOracle"
                )
            })
        })

        context("when a cardId is not in the pending request list", () => {
            it("reverts", async () => {
                await expect(
                    businessCard.connect(signers[9]).swapCallback(1, 3, altCardURI, altCardURI)
                ).to.be.revertedWithCustomError(
                    businessCard,
                    "RequestNotInPendingList"
                )

                await expect(
                    businessCard.connect(signers[9]).swapCallback(3, 2, altCardURI, altCardURI)
                ).to.be.revertedWithCustomError(
                    businessCard,
                    "RequestNotInPendingList"
                )
            })
        })

        context("after a successful call", () => {
            let tx: any;

            beforeEach(async () => {
                tx = await businessCard.connect(signers[9]).swapCallback(1, 2, altCardURI, altCardURI)
            })

            it("sets both cardURIs to the newly provided values", async () => {
                expect(await businessCard.tokenURI(1))
                    .to.be.equal(baseUri + altCardURI)

                expect(await businessCard.tokenURI(2))
                    .to.be.equal(baseUri + altCardURI)
            })

            it("removes the pending requests for both cardIds", async () => {
                expect(await businessCard.requests(1))
                    .to.be.equal(false)

                expect(await businessCard.requests(2))
                    .to.be.equal(false)
            })

            it("emits two CardURIUpdated events", async () => {
                await expect(tx)
                    .to.emit(businessCard, "CardURIUpdated")
                    .withArgs(1, baseUri + altCardURI)

                await expect(tx)
                    .to.emit(businessCard, "CardURIUpdated")
                    .withArgs(2, baseUri + altCardURI)
            })
        })
    })

    describe("setOracle", () => {
        beforeEach(async () => {
            await businessCard.connect(signers[0]).startSale()
        })

        context("when being called by someone other than the contract owner", () => {
            it("reverts", async () => {
                await expect(
                    businessCard.setOracle(accounts[8])
                ).to.be.revertedWith(
                    "Ownable: caller is not the owner"
                )
            })
        })

        context("after a successful call", () => {
            beforeEach(async () => {
                await businessCard.connect(signers[0]).setOracle(accounts[8])
            })

            it("sets the oracle address to the newly provided value", async () => {
                expect(await businessCard.oracleAddress())
                    .to.be.equal(accounts[8])
            })
        })
    })

    describe("setMarketplace", () => {
        beforeEach(async () => {
            await businessCard.connect(signers[0]).startSale()
        })

        context("when being called by someone other than the contract owner", () => {
            it("reverts", async () => {
                await expect(
                    businessCard.setMarketplace(accounts[8])
                ).to.be.revertedWith(
                    "Ownable: caller is not the owner"
                )
            })
        })

        context("after a successful call", () => {
            beforeEach(async () => {
                await businessCard.connect(signers[0]).setMarketplace(accounts[8])
            })

            it("sets the marketplace address to the newly provided value", async () => {
                expect(await businessCard.marketplaceAddress())
                    .to.be.equal(accounts[8])
            })
        })
    })

    describe("setBaseURI", () => {
        beforeEach(async () => {
            await businessCard.connect(signers[0]).startSale()
        })

        context("when being called by someone other than the contract owner", () => {
            it("reverts", async () => {
                await expect(
                    businessCard.setBaseURI(altBaseUri)
                ).to.be.revertedWith(
                    "Ownable: caller is not the owner"
                )
            })
        })

        context("after a successful call", () => {
            beforeEach(async () => {
                await businessCard.connect(signers[0]).setBaseURI(altBaseUri)
            })
            
            it("sets the baseURI to the newly provided value", async () => {
                expect(await businessCard.baseURI())
                    .to.be.equal(altBaseUri)
            })
        })
    })

    describe("devWorksHard", () => {
        beforeEach(async () => {
            await businessCard.connect(signers[0]).startSale()
        })

        context("when being called by someone other than the contract owner", () => {
            it("reverts", async () => {
                await expect(
                    businessCard.devWorksHard()
                ).to.be.revertedWith(
                    "Ownable: caller is not the owner"
                )
            })
        })

        context("after a successful call", () => {
            let tx: any;

            beforeEach(async () => {
                await businessCard.getCard(firstToken.cardName, firstToken.cardProperties, { value: MINT_PRICE })

                tx = await businessCard.connect(signers[0]).devWorksHard()
            })

            it("sends the contract balance to the msg.sender", async () => {
                expect(tx).to.changeEtherBalance(owner, MINT_PRICE.sub(ORACLE_FEE))
            })
        })
    })

    describe("isNameReserved", () => {
        beforeEach(async () => {
            await businessCard.connect(signers[0]).startSale()
        })

        context("when calling for a non reserved name", () => {
            it("returns false", async () => {
                expect(await businessCard.isNameReserved(firstToken.cardName.toLowerCase()))
                    .to.be.equal(false)
            })
        })

        context("when calling for a reserved name", () => {
            beforeEach(async () => {
                await businessCard.getCard(firstToken.cardName, firstToken.cardProperties, { value: MINT_PRICE })
            })

            it("returns true", async () => {
                expect(await businessCard.isNameReserved(firstToken.cardName.toLowerCase()))
                    .to.be.equal(true)
            })
        })
    })

    describe("getCardStats", () => {
        beforeEach(async () => {
            await businessCard.connect(signers[0]).startSale()
        })

        context("when calling for a non existing card", () => {
            it("reverts", async () => {
                await expect(
                    businessCard.getCardStats(1)
                ).to.be.revertedWithCustomError(
                    businessCard,
                    "CardDoesNotExist"
                )
            })
        })

        context("when calling for an existing card", () => {
            beforeEach(async () => {
                await businessCard.getCard(firstToken.cardName, firstToken.cardProperties, { value: MINT_PRICE })
            })

            it("returns its stats", async () => {
                const genes = await businessCard.getCardGenes(1)

                expect((await businessCard.getCardStats(1)).slice(0,2))
                    .to.deep.equal([firstToken.cardName, genes])
            })
        })
    })

    describe("getCardGenes", () => {
        beforeEach(async () => {
            await businessCard.connect(signers[0]).startSale()
        })

        context("when calling for a non existing card", () => {
            it("reverts", async () => {
                await expect(
                    businessCard.getCardGenes(1)
                ).to.be.revertedWithCustomError(
                    businessCard,
                    "CardDoesNotExist"
                )
            })
        })

        context("when calling for an existing card", () => {
            beforeEach(async () => {
                await businessCard.getCard(firstToken.cardName, firstToken.cardProperties, { value: MINT_PRICE })
            })
            
            it("returns its genes", async () => {
                const genes = await businessCard.getCardGenes(1)

                expect(genes.toString().length).to.be.at.most(30)
                expect(genes.toString().length).to.be.at.least(28)
            })
        })
    })

    describe("tokenURI", () => {
        beforeEach(async () => {
            await businessCard.connect(signers[0]).startSale()
        })

        context("when calling for a non existing card", () => {
            it("reverts", async () => {
                await expect(
                    businessCard.tokenURI(1)
                ).to.be.revertedWithCustomError(
                    businessCard,
                    "CardDoesNotExist"
                )
            })
        })

        context("when calling for a card that has not been updated yet", () => {
            beforeEach(async () => {
                await businessCard.getCard(firstToken.cardName, firstToken.cardProperties, { value: MINT_PRICE })
            })
            
            it("returns the baseURI plus the defaultURI", async () => {
                expect(await businessCard.tokenURI(1))
                    .to.be.equal(baseUri + defaultUri)
            })
        })

        context("when calling for a card that was updated", () => {
            beforeEach(async () => {
                await businessCard.getCard(firstToken.cardName, firstToken.cardProperties, { value: MINT_PRICE })
                await businessCard.connect(signers[9]).updateCallback(1, cardURI)
            })
            
            it("returns the baseURI plus the cardURI", async () => {
                expect(await businessCard.tokenURI(1))
                    .to.be.equal(baseUri + cardURI)
            })
        })
    })
})
