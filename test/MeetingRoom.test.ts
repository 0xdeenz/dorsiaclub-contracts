import { time, mine } from "@nomicfoundation/hardhat-network-helpers";
import { expect } from "chai";
import { Signer, constants, utils } from "ethers"
import { run } from "hardhat";
import { describe } from "mocha";
import {
    BusinessCard__factory,
    MeetingRoom,
    MeetingRoom__factory
} from "../typechain-types";
import { 
    createCardCommitment,
    MAXIMUM_MEETING_DURATION,
    MAXIMUM_TIME_TO_MEETING_START,
    MINIMUM_MEETING_DURATION,
    MINIMUM_TIME_TO_MEETING_START,
    MINT_PRICE
} from "./utils";

describe("MeetingRoom smart contract", () => {
    let businessCardAddress: string;
    let MeetingRoom: MeetingRoom;
    
    let meetingRoom: MeetingRoom;

    let signers: Signer[];
    let accounts: string[];

    // Example cardName and cardProperties
    const cardProperties = {
        position: 'Vice President',
        twitterAccount: 'twitterAccount',
        telegramAccount: 'telegramAccount',
        githubAccount: 'githubAccount',
        website: 'website.com'
    }
    
    const firstToken = {
        cardName: 'Patrick BATEMAN',
        cardProperties,
        commitment: createCardCommitment(1, 350)
    };
    
    const secondToken = {
        cardName: 'Paul ALLEN',
        cardProperties,
        commitment: createCardCommitment(2, 350)
    };
    
    const thirdToken = {
        cardName: 'David VAN PATTEN',
        cardProperties,
        commitment: createCardCommitment(3, 350)
    };

    // URI parameters
    const baseUri = 'https://gateway.pinata.cloud/ipfs/Qm';
    const defaultUri = 'bFp3rybuvZ7j9e4xB6WLedu8gvLcjbVqUrGUEugQWz9u';

    // Filler value, would be dynamically generated by the server oracle
    const tokenURI = 'Ur63bgQq3VWW9XsVviDGAFwYEZVs9AFWsTd56T9xCQmf'

    const betAmount = utils.parseEther("0.01");

    before(async () => {
        signers = await run("accounts")
        accounts = await Promise.all(signers.map((signer: Signer) => signer.getAddress()));

        ({ businessCardAddress } = await run("deploy:business-card", { 
            baseUri,
            defaultUri,
            oracleAddress: accounts[9],
            deployMarketplace: false
        }))

        const businessCard = BusinessCard__factory.connect(businessCardAddress, signers[1])

        await businessCard.connect(signers[1]).getCard(firstToken.cardName, firstToken.cardProperties, { value: MINT_PRICE })
        await businessCard.connect(signers[2]).getCard(secondToken.cardName, secondToken.cardProperties, { value: MINT_PRICE })
        await businessCard.connect(signers[3]).getCard(thirdToken.cardName, thirdToken.cardProperties, { value: MINT_PRICE })
    })

    beforeEach(async () => {
        const { meetingRoomAddress } = await run("deploy:meeting-room", { 
            businessCardAddress
        })

        meetingRoom = MeetingRoom__factory.connect(meetingRoomAddress, signers[1])
    })

    describe("createMeetingRoom", () => {
        context("when the initial bet is zero", () => {
            it("reverts", async () => {
                await expect(
                    meetingRoom.createMeetingRoom(firstToken.commitment, MINIMUM_TIME_TO_MEETING_START, MINIMUM_MEETING_DURATION)
                ).to.be.revertedWithCustomError(
                    meetingRoom,
                    "InvalidBetAmount"
                )
            })
        })

        context("when the given time to meeting start is below the minimum", () => {
            it("reverts", async () => {
                await expect(
                    meetingRoom.createMeetingRoom(firstToken.commitment, MINIMUM_TIME_TO_MEETING_START - 1, MINIMUM_MEETING_DURATION, { value: betAmount })
                ).to.be.revertedWithCustomError(
                    meetingRoom,
                    "InvalidTimeToMeetingStart"
                )
            })
        })

        context("when the given time to meeting start is above the maximum", () => {
            it("reverts", async () => {
                await expect(
                    meetingRoom.createMeetingRoom(firstToken.commitment, MAXIMUM_TIME_TO_MEETING_START + 1, MINIMUM_MEETING_DURATION, { value: betAmount })
                ).to.be.revertedWithCustomError(
                    meetingRoom,
                    "InvalidTimeToMeetingStart"
                )
            })
        })

        context("when the given meeting duration is below the minimum", () => {
            it("reverts", async () => {
                await expect(
                    meetingRoom.createMeetingRoom(firstToken.commitment, MINIMUM_TIME_TO_MEETING_START, MINIMUM_MEETING_DURATION - 1, { value: betAmount })
                ).to.be.revertedWithCustomError(
                    meetingRoom,
                    "InvalidMeetingDuration"
                )
            })
        })

        context("when the given meeting duration is above the maximum", () => {
            it("reverts", async () => {
                await expect(
                    meetingRoom.createMeetingRoom(firstToken.commitment, MAXIMUM_TIME_TO_MEETING_START, MAXIMUM_MEETING_DURATION + 1, { value: betAmount })
                ).to.be.revertedWithCustomError(
                    meetingRoom,
                    "InvalidMeetingDuration"
                )
            })
        })

        context("after a successful call", () => {
            let tx: any; 
            let meetingStart: number;
            let meetingEnd: number;
            
            beforeEach(async () => {
                tx = await meetingRoom.createMeetingRoom(firstToken.commitment, MINIMUM_TIME_TO_MEETING_START, MINIMUM_MEETING_DURATION, { value: betAmount })
                
                meetingStart = (await time.latest()) + MINIMUM_TIME_TO_MEETING_START * 60
                meetingEnd = (await time.latest()) + MINIMUM_TIME_TO_MEETING_START * 60 + MINIMUM_MEETING_DURATION * 60
            })

            it("increases the number of meeting rooms", async () => {
                expect(await meetingRoom.totalMeetingRooms())
                    .to.be.equal(1)
            })

            it("stores the initial card commitment for this meeting room", async () => {
                expect(await meetingRoom.cardCommitments(1, accounts[1]))
                    .to.be.equal(firstToken.commitment)
            })

            it("defines the corresponding meeting room", async () => {
                tx.a
                expect((await meetingRoom.getMeetingRoom(1)).slice(0, 7))
                    .to.deep.equal([meetingStart, meetingEnd, betAmount, 1, [], [], constants.AddressZero])
            })

            it("emits a MeetingRoomCreated event", async () => {
                await expect(tx)
                    .to.emit(meetingRoom, "MeetingRoomCreated")
                    .withArgs(1, betAmount, meetingStart, meetingEnd, firstToken.commitment, accounts[1])
            })
        })
    })

    describe("joinMeetingRoom", () => {
        let tx: any; 
        let meetingStart: number;
        let meetingEnd: number;
        
        beforeEach(async () => {
            tx = await meetingRoom.createMeetingRoom(firstToken.commitment, MINIMUM_TIME_TO_MEETING_START, MINIMUM_MEETING_DURATION, { value: betAmount })
            
            meetingStart = (await time.latest()) + MINIMUM_TIME_TO_MEETING_START * 60
            meetingEnd = (await time.latest()) + MINIMUM_TIME_TO_MEETING_START * 60 + MINIMUM_MEETING_DURATION * 60
        })

        context("when trying to join a meeting that was already started", () => {
            it("reverts", async () => {
                time.increase(MINIMUM_TIME_TO_MEETING_START * 60)

                await expect(
                    meetingRoom.connect(signers[2]).joinMeetingRoom(1, secondToken.commitment, { value: betAmount })
                ).to.be.revertedWithCustomError(
                    meetingRoom,
                    "MeetingOngoing"
                )
            })
        })

        context("when trying to join with an invalid bet amount", () => {
            it("reverts", async () => {
                await expect(
                    meetingRoom.connect(signers[2]).joinMeetingRoom(1, secondToken.commitment, { value: betAmount.sub(1) })
                ).to.be.revertedWithCustomError(
                    meetingRoom,
                    "InvalidBetAmount"
                )

                await expect(
                    meetingRoom.connect(signers[2]).joinMeetingRoom(1, secondToken.commitment, { value: betAmount.add(1) })
                ).to.be.revertedWithCustomError(
                    meetingRoom,
                    "InvalidBetAmount"
                )
            })
        })
    })

    describe("revealCard", () => {
        it("TODO", () => {
            expect(true).to.be.equal(false)
        })
    })

    describe("finishMeeting", () => {
        it("TODO", () => {
            expect(true).to.be.equal(false)
        })
    })

    describe("withdraw", () => {
        it("TODO", () => {
            expect(true).to.be.equal(false)
        })
    })

    describe("getMeetingRoom", () => {
        it("TODO", () => {
            expect(true).to.be.equal(false)
        })        
    })
})
